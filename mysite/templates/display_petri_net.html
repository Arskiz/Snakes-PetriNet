{% extends "base.html" %}

{% block pageTitle %}
Petri Net Analysis: {{ filename }}
{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ static('assets/style-petrinet.css') }}">
{% endblock %}

{% block content %}
<div class="petri-container">
    <div class="petri-header">
        <h1>Petri Net Analysis</h1>
        <p class="petri-filename">{{ filename }}</p>
    </div>
    
    <!-- Visualization Section -->
    <div class="visualization-section">
        <h2>Visual Representation</h2>
        <div class="canvas-container">
            
        </div>
    </div>
    
    <!-- Data Tabs Section -->
    <div class="data-tabs-section">
        <div class="tabs">
            <button class="tab-button active" onclick="openTab(event, 'places-tab')">Places</button>
            <button class="tab-button" onclick="openTab(event, 'transitions-tab')">Transitions</button>
            <button class="tab-button" onclick="openTab(event, 'stats-tab')">Statistics</button>
        </div>
        
        <!-- Places Tab -->
        <div id="places-tab" class="tab-content active">
            <div class="table-container">
                <table class="petri-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Tokens</th>
                            <th>Position</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for place in petri_net_data.places %}
                        <tr>
                            <td>{{ place.id }}</td>
                            <td>{{ place.name }}</td>
                            <td>{{ place.tokens }}</td>
                            <td>({{ place.top }}, {{ place.left }})</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Transitions Tab -->
        <div id="transitions-tab" class="tab-content">
            <div class="table-container">
                <table class="petri-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>From Places</th>
                            <th>To Places</th>
                            <th>Position</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for transition in petri_net_data.transitions %}
                        <tr>
                            <td>{{ transition.id }}</td>
                            <td>{{ transition.name }}</td>
                            <td>{{ transition.from|join(", ") }}</td>
                            <td>{{ transition.to|join(", ") }}</td>
                            <td>({{ transition.top }}, {{ transition.left }})</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Statistics Tab -->
        <div id="stats-tab" class="tab-content">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">{{ petri_net_data.places|length }}</div>
                    <div class="stat-label">Places</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{{ petri_net_data.transitions|length }}</div>
                    <div class="stat-label">Transitions</div>
                </div>
                <div class="stat-card">
                    {% set total_tokens = 0 %}
                    {% for place in petri_net_data.places %}
                        {% set total_tokens = total_tokens + place.tokens|int %}
                    {% endfor %}
                    <div class="stat-value">{{ total_tokens }}</div>
                    <div class="stat-label">Total Tokens</div>
                </div>
                <div class="stat-card">
                    {% set arc_count = 0 %}
                    {% for transition in petri_net_data.transitions %}
                        {% set arc_count = arc_count + transition.from|length + transition.to|length %}
                    {% endfor %}
                    <div class="stat-value">{{ arc_count }}</div>
                    <div class="stat-label">Arcs</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Actions Section -->
    <div class="actions-section">
        <button class="action-button primary" onclick="$('#popupDialog').popup('open');">
            <span class="button-icon">+</span>
            Import Another File
        </button>
        
        <a href="{{ url('delete_petri_net_data', args=[filename]) }}" 
           class="action-button danger" 
           onclick="return confirm('Are you sure you want to delete this Petri Net data from the server?');">
            <span class="button-icon">üóëÔ∏è</span>
            Delete Petri Net Data
        </a>
    </div>
</div>

<!-- Pop-up dialog for file selection -->
<div data-role="popup" id="popupDialog" data-overlay-theme="b" data-theme="a" data-dismissible="false" class="file-upload-popup">
    <div class="popup-header">
        <h3>Import Petri Net File</h3>
        <button class="close-button" onclick="window.location.href = '#'" data-rel="back">√ó</button>
    </div>
    
    <div class="popup-content">
        <p>Select a CPN file to analyze.</p>
        
        <form id="fileUploadForm" method="POST" enctype="multipart/form-data">
            <input type="hidden" id="csrf_token" value="{{ csrf_token }}">
            
            <div class="file-input-container">
                <input type="file" accept=".py" id="fileInput" name="file" onchange="updateFileName()" />
                <label for="fileInput" class="file-input-label">
                    <span class="file-icon">üìÅ</span>
                    <span>Choose File</span>
                </label>
                <p id="fileName" class="selected-filename"></p>
            </div>
            
            <div class="popup-actions">
                <button type="button" onclick="window.location.href = '#'" class="popup-button secondary" data-rel="back">Cancel</button>
                <button type="button" class="popup-button primary" onclick="uploadFile()">Import</button>
            </div>
        </form>
    </div>
</div>

<script>
    // Tab switching functionality
    function openTab(evt, tabName) {
        // Hide all tab content
        var tabContents = document.getElementsByClassName("tab-content");
        for (var i = 0; i < tabContents.length; i++) {
            tabContents[i].classList.remove("active");
        }
        
        // Remove active class from all tab buttons
        var tabButtons = document.getElementsByClassName("tab-button");
        for (var i = 0; i < tabButtons.length; i++) {
            tabButtons[i].classList.remove("active");
        }
        
        // Show the selected tab content and mark button as active
        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
    }

    // File input handling
    function updateFileName() {
        var input = document.getElementById('fileInput');
        var fileName = document.getElementById('fileName');
        if (input.files.length > 0) {
            fileName.innerText = input.files[0].name;
        } else {
            fileName.innerText = "";
        }
    }

    function uploadFile() {
        var input = document.getElementById('fileInput');
        if (input.files.length === 0) {
            alert("No file selected!");
            return;
        }

        var formData = new FormData();
        formData.append('file', input.files[0]);
        var csrfToken = document.getElementById('csrf_token').value;

        // Show loading state
        document.getElementById('fileName').innerHTML = '<span class="loading-spinner"></span> Uploading...';
        
        fetch("{{ url('upload_file') }}", {
            method: "POST",
            body: formData,
            headers: {
                "X-CSRFToken": csrfToken
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('fileName').innerHTML = '<span class="success-icon">‚úì</span> Upload successful!';
                setTimeout(() => {
                    $('#popupDialog').popup('close');
                    if (data.redirect_url) {
                        window.location.href = data.redirect_url;
                    }
                }, 1000);
            } else {
                document.getElementById('fileName').innerHTML = '<span class="error-icon">‚ö†Ô∏è</span> ' + (data.error || data.message || "Unknown error");
            }
        })
        .catch(error => {
            console.error("Error:", error);
            document.getElementById('fileName').innerHTML = '<span class="error-icon">‚ö†Ô∏è</span> Upload failed';
        });
    }
</script>

<script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
   // Replace the canvas visualization with this D3.js implementation
document.addEventListener('DOMContentLoaded', function() {
    const petriNetData = {{ petri_net_data|safe }};
    
    // Create nodes and links arrays for D3
    const nodes = [];
    const links = [];
    
    // Add places as nodes
    petriNetData.places.forEach(place => {
        nodes.push({
            id: place.id,
            name: place.name || place.id,
            type: 'place',
            tokens: place.tokens || 0
        });
    });
    
    // Add transitions as nodes
    petriNetData.transitions.forEach(transition => {
        nodes.push({
            id: transition.id,
            name: transition.name || transition.id,
            type: 'transition'
        });
        
        // Add arcs from places to this transition
        transition.from.forEach(placeId => {
            links.push({
                source: placeId,
                target: transition.id,
                type: 'input'
            });
        });
        
        // Add arcs from this transition to places
        transition.to.forEach(placeId => {
            links.push({
                source: transition.id,
                target: placeId,
                type: 'output',
                weight: transition.weights ? (transition.weights[placeId] || 1) : 1
            });
        });
    });
    
    // Add weights if available in the arcs array
    if (petriNetData.arcs && petriNetData.arcs.length) {
        petriNetData.arcs.forEach(arc => {
            // Find the corresponding link
            const link = links.find(l => 
                l.source === arc.source && 
                l.target === arc.target
            );
            
            if (link) {
                link.weight = arc.weight || 1;
            }
        });
    }
    
    // Set up SVG container
    const container = d3.select('.canvas-container');
    const containerWidth = container.node().getBoundingClientRect().width;
    const containerHeight = container.node().getBoundingClientRect().height;
    
    // Remove any existing SVG (for redraw)
    container.select('svg').remove();
    
    // Create SVG element
    const svg = container.append('svg')
        .attr('width', containerWidth)
        .attr('height', containerHeight)
        .attr('id', 'petri-net-svg')
        .call(d3.zoom().on('zoom', function(event) {
            g.attr('transform', event.transform);
        }));
    
    // Add a defs section for markers (arrow heads)
    const defs = svg.append('defs');
    
    // Define arrow head for input arcs
    defs.append('marker')
        .attr('id', 'input-arrow')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 5)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', 'rgba(0, 95, 122, 0.8)');
    
    // Define arrow head for output arcs
    defs.append('marker')
        .attr('id', 'output-arrow')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 5)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', 'rgba(81, 101, 64, 0.8)');
    
    // Create a group to contain the entire visualization
    const g = svg.append('g');
    
    // Create the force simulation
    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(containerWidth / 2, containerHeight / 2))
        .force('collision', d3.forceCollide().radius(d => d.type === 'place' ? 35 : 25))
        .force('x', d3.forceX(containerWidth / 2).strength(0.05))
        .force('y', d3.forceY(containerHeight / 2).strength(0.05));
    
    // Create links (arcs)
    const link = g.append('g')
        .attr('class', 'links')
        .selectAll('path')
        .data(links)
        .join('path')
        .attr('class', 'link')
        .attr('stroke', d => d.type === 'input' ? 'rgba(0, 95, 122, 0.8)' : 'rgba(81, 101, 64, 0.8)')
        .attr('stroke-width', 2)
        .attr('fill', 'none')
        .attr('marker-end', d => d.type === 'input' ? 'url(#input-arrow)' : 'url(#output-arrow)');
    
    // Create weight labels
    const weightLabel = g.append('g')
        .attr('class', 'weight-labels')
        .selectAll('g')
        .data(links.filter(d => d.weight && d.weight !== 1))
        .join('g');
    
    weightLabel.append('circle')
        .attr('r', 10)
        .attr('fill', 'rgba(255, 255, 255, 0.8)');
    
    weightLabel.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', 4)
        .attr('font-size', 12)
        .attr('font-weight', 'bold')
        .attr('fill', '#0a3541')
        .text(d => d.weight);
    
    // Create nodes
    const node = g.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(nodes)
        .join('g')
        .attr('class', d => `node ${d.type}`)
        .call(d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended));
    
    // Add tooltips
    node.append('title')
        .text(d => `${d.id} (${d.name})`);
    
    // Add different shapes for places and transitions
    node.each(function(d) {
        const element = d3.select(this);
        
        if (d.type === 'place') {
            // Create gradient for places
            const gradientId = `place-gradient-${d.id.replace(/\s+/g, '-')}`;
            const gradient = defs.append('radialGradient')
                .attr('id', gradientId)
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '50%')
                .attr('fx', '50%')
                .attr('fy', '50%');
                
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', 'rgba(255, 255, 255, 0.9)');
                
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', 'rgba(200, 200, 255, 0.7)');
            
            // Create place circle
            element.append('circle')
                .attr('r', 25)
                .attr('fill', `url(#${gradientId})`)
                .attr('stroke', 'rgba(0, 95, 122, 0.8)')
                .attr('stroke-width', 2)
                .attr('filter', 'drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.2))');
            
            // Add tokens if any
            if (d.tokens > 0) {
                if (d.tokens === 1) {
                    element.append('circle')
                        .attr('r', 5)
                        .attr('fill', 'rgba(0, 95, 122, 0.8)');
                } else {
                    element.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dy', 5)
                        .attr('font-size', 14)
                        .attr('font-weight', 'bold')
                        .attr('fill', '#0a3541')
                        .text(d.tokens);
                }
            }
        } else {
            // Create gradient for transitions
            const gradientId = `transition-gradient-${d.id.replace(/\s+/g, '-')}`;
            const gradient = defs.append('linearGradient')
                .attr('id', gradientId)
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '100%')
                .attr('y2', '100%');
                
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', 'rgba(81, 101, 64, 0.8)');
                
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', 'rgba(81, 101, 64, 0.6)');
            
            // Create transition rectangle
            element.append('rect')
                .attr('x', -15)
                .attr('y', -10)
                .attr('width', 30)
                .attr('height', 20)
                .attr('fill', `url(#${gradientId})`)
                .attr('stroke', 'rgba(81, 101, 64, 0.9)')
                .attr('stroke-width', 2)
                .attr('filter', 'drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.2))');
        }
        
        // Add label
        element.append('text')
            .attr('dy', d => d.type === 'place' ? -30 : -15)
            .attr('text-anchor', 'middle')
            .attr('fill', '#0a3541')
            .text(d.id);
    });
    
    // Helper function to calculate a point along a quadratic Bezier curve
    function pointOnQuadraticBezier(p0, p1, p2, t) {
        const x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x;
        const y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y;
        return { x, y };
    }
    
    // Update link positions during simulation
    simulation.on('tick', () => {
        // Update links with curved paths
        link.attr('d', d => {
            // Get source and target coordinates
            const sourceNode = nodes.find(n => n.id === d.source.id || n.id === d.source);
            const targetNode = nodes.find(n => n.id === d.target.id || n.id === d.target);
            
            if (!sourceNode || !targetNode) return '';
            
            // Extract coordinates
            const sourceX = sourceNode.x;
            const sourceY = sourceNode.y;
            const targetX = targetNode.x;
            const targetY = targetNode.y;
            
            // Calculate midpoint
            const midX = (sourceX + targetX) / 2;
            const midY = (sourceY + targetY) / 2;
            
            // Calculate distance
            const dx = targetX - sourceX;
            const dy = targetY - sourceY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Adjust curvature based on distance
            let curvature = 0;
            if (distance > 150) {
                curvature = 0.2;
            } else if (distance > 80) {
                curvature = 0.1;
            }
            
            // Calculate control point offset perpendicular to the line
            const offsetX = -dy * curvature;
            const offsetY = dx * curvature;
            
            // Calculate control point
            const controlX = midX + offsetX;
            const controlY = midY + offsetY;
            
            // Start and end nodes have different radii
            const sourceRadius = sourceNode.type === 'place' ? 25 : 15;
            const targetRadius = targetNode.type === 'place' ? 25 : 15;
            
            // Calculate the angle to adjust start and end points
            const angle = Math.atan2(targetY - sourceY, targetX - sourceX);
            
            // Adjust start and end points to begin/end at the node perimeter
            const startX = sourceX + (sourceRadius * Math.cos(angle));
            const startY = sourceY + (sourceRadius * Math.sin(angle));
            
            // For the target, we need to move inward from the edge a bit to accommodate the arrowhead
            const endX = targetX - ((targetRadius + 5) * Math.cos(angle));
            const endY = targetY - ((targetRadius + 5) * Math.sin(angle));
            
            // Store path parameters on the data for weight label positioning
            d.pathParams = {
                start: { x: startX, y: startY },
                control: { x: controlX, y: controlY },
                end: { x: endX, y: endY }
            };
            
            // Generate curved path
            return `M${startX},${startY} Q${controlX},${controlY} ${endX},${endY}`;
        });
        
        // Update weight labels - FIXED to be on the curve
        weightLabel.attr('transform', d => {
            // If we don't have path parameters yet, skip
            if (!d.pathParams) return '';
            
            // Calculate point on the Bezier curve at t=0.5 (midpoint)
            const bezierPoint = pointOnQuadraticBezier(
                d.pathParams.start, 
                d.pathParams.control, 
                d.pathParams.end, 
                0.5
            );
            
            return `translate(${bezierPoint.x}, ${bezierPoint.y})`;
        });
        
        // Update node positions
        node.attr('transform', d => `translate(${d.x}, ${d.y})`);
    });
    
    // Drag functions
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        // Keep node fixed where user dragged it
        // d.fx = null;
        // d.fy = null;
    }
    
    // Add legend
    const legendWidth = 120;
    const legendHeight = 140;
    const legendX = containerWidth - legendWidth - 10;
    const legendY = 10;
    
    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${legendX}, ${legendY})`);
    
    // Legend background
    legend.append('rect')
        .attr('width', legendWidth)
        .attr('height', legendHeight)
        .attr('rx', 8)
        .attr('ry', 8)
        .attr('fill', 'rgba(255, 255, 255, 0.9)')
        .attr('stroke', 'rgba(0, 0, 0, 0.1)');
    
    // Legend title
    legend.append('text')
        .attr('x', 10)
        .attr('y', 20)
        .attr('font-size', 12)
        .attr('font-weight', 'bold')
        .attr('fill', '#0a3541')
        .text('Legend');
    
    // Place legend item
    const placeLegend = legend.append('g')
        .attr('transform', 'translate(15, 40)');
    
    placeLegend.append('circle')
        .attr('r', 10)
        .attr('fill', 'rgba(200, 200, 255, 0.7)')
        .attr('stroke', 'rgba(0, 95, 122, 0.8)')
        .attr('stroke-width', 2);
    
    placeLegend.append('text')
        .attr('x', 20)
        .attr('y', 4)
        .attr('font-size', 12)
        .attr('fill', '#0a3541')
        .text('Place');
    
    // Transition legend item
    const transitionLegend = legend.append('g')
        .attr('transform', 'translate(15, 70)');
    
    transitionLegend.append('rect')
        .attr('x', -10)
        .attr('y', -7)
        .attr('width', 20)
        .attr('height', 14)
        .attr('fill', 'rgba(81, 101, 64, 0.8)')
        .attr('stroke', 'rgba(81, 101, 64, 0.9)')
        .attr('stroke-width', 2);
    
    transitionLegend.append('text')
        .attr('x', 20)
        .attr('y', 4)
        .attr('font-size', 12)
        .attr('fill', '#0a3541')
        .text('Transition');
    
    // Input arc legend item
    const inputArcLegend = legend.append('g')
        .attr('transform', 'translate(15, 100)');
    
    inputArcLegend.append('line')
        .attr('x1', -10)
        .attr('y1', 0)
        .attr('x2', 10)
        .attr('y2', 0)
        .attr('stroke', 'rgba(0, 95, 122, 0.8)')
        .attr('stroke-width', 2)
        .attr('marker-end', 'url(#input-arrow)');
    
    inputArcLegend.append('text')
        .attr('x', 20)
        .attr('y', 4)
        .attr('font-size', 12)
        .attr('fill', '#0a3541')
        .text('Input Arc');
    
    // Output arc legend item
    const outputArcLegend = legend.append('g')
        .attr('transform', 'translate(15, 130)');
    
    outputArcLegend.append('line')
        .attr('x1', -10)
        .attr('y1', 0)
        .attr('x2', 10)
        .attr('y2', 0)
        .attr('stroke', 'rgba(81, 101, 64, 0.8)')
        .attr('stroke-width', 2)
        .attr('marker-end', 'url(#output-arrow)');
    
    outputArcLegend.append('text')
        .attr('x', 20)
        .attr('y', 4)
        .attr('font-size', 12)
        .attr('fill', '#0a3541')
        .text('Output Arc');
    
    // Handle window resize
    window.addEventListener('resize', () => {
        // Get new dimensions
        const newWidth = container.node().getBoundingClientRect().width;
        const newHeight = container.node().getBoundingClientRect().height;
        
        // Update SVG size
        svg.attr('width', newWidth)
           .attr('height', newHeight);
        
        // Update forces
        simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2))
                 .force('x', d3.forceX(newWidth / 2).strength(0.05))
                 .force('y', d3.forceY(newHeight / 2).strength(0.05))
                 .alpha(0.3)
                 .restart();
        
        // Move legend
        legend.attr('transform', `translate(${newWidth - legendWidth - 10}, 10)`);
    });
    
    // Add CSS styles for D3 elements
    const style = document.createElement('style');
    style.textContent = `
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #petri-net-svg {
            background-color: transparent;
            cursor: move;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node:hover text {
            font-weight: bold;
        }
        
        .link {
            pointer-events: none;
        }
    `;
    document.head.appendChild(style);
});
</script>

{% endblock %}

<!-- Right side of the header -->
{% block rightHeaderContent %}
<div class="Hoverable" id="HomeBtn" onclick="$('#popupDialog').popup('open');">
    <h1 class="nonSelectable white conChild HeaderElementText">Import File</h1>
    <img
        src="{{ static('assets/icons/upload.png') }}"
        class="conChild" height="20px"
        style="filter: invert(100%);"
        alt="upload-icon">
</div>

<div class="Hoverable" id="HomeBtn" onclick="redirect(999)">
    <h1 class="nonSelectable white conChild HeaderElementText">Home</h1>
    <img
        src="{{ static('assets/icons/home.png') }}"
        class="conChild" height="20px"
        style="filter: invert(100%);"
        alt="home-icon">
</div>
{% endblock %}

<!-- Footer -->
{% block footerTxt %}
Copyright ¬© DIGIT, Inc. 2025. All rights reserved.
{% endblock %}

{% block burger1 %} $('#popupDialog').popup('open'); {% endblock %}
{% block burger1Text %} Import A File {% endblock %}

{% block burger2 %} redirect(1) {% endblock %}
{% block burger2Text %} About {% endblock %}